section .rodata
    align 0x40
    first_15:       db  '1', 10, '2', 10, 'Fizz', 10, '4', 10, 'Buzz', 10, 'Fizz', 10, '7', 10, '8', 10, \
                        'Fizz', 10, 'Buzz', 10, '11', 10, 'Fizz', 10, '13', 10, '14', 10, 'FizzBuzz', 10

section .bss
    numbufsz        equ (1 << 6)
    align 0x40
    num_buf:        resb numbufsz

    bufsz           equ (1 << 16)
    align 0x1000
    io_buffer:      resb bufsz

section .text
    global _start
    global u64_to_str
    global buf_empty
    global buf_write_u64
    global fizzbuzz_main

align 0x1000
_start:
    ; initialization
    vpxor ymm0, ymm0, ymm0      ; zero out ymm0
    mov r13, 58                 ; holds buffer size
    mov r14d, 0x7A7A7542        ; Buzz (but backwards bc. endianness)
    mov r15, 0x7A7A75427A7A6946 ; FizzBuzz
    vmovdqa ymm1, [first_15]
    vmovdqa ymm2, [first_15 + 32]
    vmovdqa [io_buffer], ymm1
    vmovdqa [io_buffer + 32], ymm2
;   mov rax, 0x4141414141414141
;   vmovq xmm1, rax
;   vpbroadcastq ymm1, xmm1
;   vmovdqu [io_buffer + (1 << 16) - 32], ymm1
    xor rax, rax
    call fizzbuzz_main
    jmp exit

align 0x40
fizzbuzz_main:
    push rbx
    mov r12, -1 ; number of iterations
    mov rbx, 16  ; loop counter
loop_start:
    mov rdi, rbx
    call u64_to_str
    mov rdi, num_buf + 0x20
    sub rdi, rax
    mov rsi, rax
    call buf_write_u64
    inc rbx
    mov rdi, rbx
    call u64_to_str
    mov rdi, num_buf + 0x20
    sub rdi, rax
    mov rsi, rax
    call buf_write_u64

    ; Fizz (3)
    cmp r13, bufsz-5
    jna fizz_3
    call buf_empty
fizz_3: 
    mov dword [io_buffer + r13], r15d
    mov byte [io_buffer + r13 + 4], 0xA
    lea r13, [r13+5]
    add rbx, 2

    mov rdi, rbx
    call u64_to_str
    mov rdi, num_buf + 0x20
    sub rdi, rax
    mov rsi, rax
    call buf_write_u64

    ; Buzz (5)
    cmp r13, bufsz-5
    jna buzz_5
    call buf_empty
buzz_5:
    mov dword [io_buffer + r13], r14d
    mov byte [io_buffer + r13 + 4], 0xA
    lea r13, [r13+5]

    ; Fizz (6)
    cmp r13, bufsz-5
    jna fizz_6
    call buf_empty
fizz_6:
    mov dword [io_buffer + r13], r15d
    mov byte [io_buffer + r13 + 4], 0xA
    lea r13, [r13+5]
    add rbx, 3

    mov rdi, rbx
    call u64_to_str
    mov rdi, num_buf + 0x20
    sub rdi, rax
    mov rsi, rax
    call buf_write_u64
    inc rbx
    mov rdi, rbx
    call u64_to_str
    mov rdi, num_buf + 0x20
    sub rdi, rax
    mov rsi, rax
    call buf_write_u64

    ; Fizz (9)
    cmp r13, bufsz-5
    jna fizz_9
    call buf_empty
fizz_9:
    mov dword [io_buffer + r13], r15d
    mov byte [io_buffer + r13 + 4], 0xA
    lea r13, [r13+5]

    ; Buzz (10)
    cmp r13, bufsz-5
    jna buzz_10
    call buf_empty
buzz_10:
    mov dword [io_buffer + r13], r14d
    mov byte [io_buffer + r13 + 4], 0xA
    lea r13, [r13+5]
    lea rbx, [rbx+3]

    mov rdi, rbx
    call u64_to_str
    mov rdi, num_buf + 0x20
    sub rdi, rax
    mov rsi, rax
    call buf_write_u64

    ; Fizz (12)
    cmp r13, bufsz-5
    jna fizz_12
    call buf_empty
fizz_12:
    mov dword [io_buffer + r13], r15d
    mov byte [io_buffer + r13 + 4], 0xA
    lea r13, [r13+5]
    add rbx, 2

    mov rdi, rbx
    call u64_to_str
    mov rdi, num_buf + 0x20
    sub rdi, rax
    mov rsi, rax
    call buf_write_u64
    inc rbx
    mov rdi, rbx
    call u64_to_str
    mov rdi, num_buf + 0x20
    sub rdi, rax
    mov rsi, rax
    call buf_write_u64
    inc rbx

    ; FizzBuzz (15)
    cmp r13, bufsz-9
    jna fizzbuzz_15
    call buf_empty
fizzbuzz_15:
    mov qword [io_buffer + r13], r15
    mov byte [io_buffer + r13 + 8], 0xA
    lea r13, [r13+9]
    inc rbx

    cmp rbx, r12
    jb loop_start
    pop rbx
    ret

align 0x40
; appends a u64 string (rdi) with length (rsi) to the i/o buffer
buf_write_u64:
    mov rdx, rsi
    lea rdx, [rdx+r13]
    cmp rdx, bufsz-1    ; minus 1 to account for a newline
    jb append           ; jump to appending, there is enough space :^)
    push rdi
    push rsi
    call buf_empty
    pop rsi
    pop rdi
append:
    xor rcx, rcx
    cmp rsi, 0x07       ; checks if we can move a whole qword in one go
    jbe append_loop
    mov rcx, [rdi]
    mov [io_buffer + r13], rcx 
    mov rcx, 0x8
    cmp rsi, 0x08
    je append_exit
append_loop:
    movzx edx, word [rdi + rcx]
    mov byte [io_buffer + rcx + r13], dl
    inc rcx
    cmp rcx, rsi
    jne append_loop
append_exit:
    mov byte [io_buffer + rcx + r13], 0xA
    inc rcx
    lea r13, [r13+rcx]
    ret

align 0x20
; empty io buffer (write out)
buf_empty:
    mov rsi, io_buffer
    mov rdx, r13
    mov rdi, 1
    mov rax, 1
    syscall
    xor r13, r13
    ret

align 0x20
; utility subroutine to convert an unsigned integer (rdi)
; to a string (not zero terminated)
u64_to_str:
    vmovdqa [rel num_buf], ymm0 ; copy ymm0 into buffer
    test rdi, rdi
    je iszero
    xor rcx, rcx
    ; some tricks used to avoid the `div` instruction
    ; copied from assembly generated by clang
    mov r8, 0xCCCCCCCCCCCCCCCD
inner_loop:
    mov rax, rdi
    mul r8
    shr rdx, 3
    lea eax, [rdx + rdx]
    lea r9d, [rax + 4*rax]
    mov eax, edi
    sub eax, r9d
    or al, 0x30
    mov byte [num_buf + rcx + 31], al
    add rcx, -1
    cmp rdi, 9
    mov rdi, rdx
    ja inner_loop
    neg rcx
    mov rax, rcx
    ret
iszero:
    mov byte [rel num_buf + 31], 0x30 ; ASCII '0'
    mov rax, 0x1
    ret

align 0x20
exit:
    call buf_empty
    mov rax, 0x3c
    xor rdi, rdi
    syscall
